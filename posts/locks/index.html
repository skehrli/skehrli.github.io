<!-- Generated from 747d082 on 2024-03-31 @ 14:46 with Emacs 27.2 (Org mode 9.4.4) -->
<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"/><meta author="Sascha Kehrli"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><link rel="icon" type="image/png" href="/img/favicon.png"/><link rel="alternative" type="application/rss+xml" title="System Crafters News" href="https://skehrli.github.io/rss/news.xml"/><link rel="stylesheet" href="https://skehrli.github.io/fonts/iosevka-aile/iosevka-aile.css"/><link rel="stylesheet" href="https://skehrli.github.io/fonts/jetbrains-mono/jetbrains-mono.css"/><link rel="stylesheet" href="https://skehrli.github.io/css/code.css"/><link rel="stylesheet" href="https://skehrli.github.io/css/site.css"/><script defer="defer" data-domain="systemcrafters.net" src="https://plausible.io/js/plausible.js"></script><title>An Overview of Locking Algorithms</title></head><body><header class="site-header"><div class="container"><div class="site-title"><img class="logo" src="https://skehrli.github.io" alt="Sascha Kehrli"/></div></div><div class="site-masthead"><div class="container"><nav class="nav"><a class="nav-link" href="/">Home</a> <a class="nav-link" href="/posts/posts">Posts</a> <a class="nav-link" href="/cv/cv">CV</a></nav></div></div></header><div class="container"><div class="site-post"><h1 class="site-post-title">An Overview of Locking Algorithms</h1><p class="site-post-meta"></p><div id="content"><p>
Some time ago I TAed <i>Parallel Programming</i>, which covers a multitude of software locking algorithms. They solve the mutual exclusion problem for two or more threads. This is an overview of how they compare in key properties, such as starvation-freedom and fairness and includes some proof sketches of those properties (the ones I found interesting). However, we&rsquo;re not discussing how the locks themselves work. Rather is this a writeup of the more surprising and non-obvious properties/proofs I&rsquo;ve found when covering this in my classes.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> Comparing Different Mutual-Exclusion Algorithms</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Algorithm</th>
<th scope="col" class="org-left">Mutually Exclusive</th>
<th scope="col" class="org-left">Starvation-Free</th>
<th scope="col" class="org-left">Deadlock-Free</th>
<th scope="col" class="org-left">Fair (FIFO)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Peterson Lock</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">Dekker Lock</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">Filter Lock</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">Bakery Lock</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">Atomic-RMW-Locks</td>
<td class="org-left">Yes</td>
<td class="org-left">No</td>
<td class="org-left">Yes</td>
<td class="org-left">No</td>
</tr>
</tbody>
</table>

<h2><a id="before-we-start-assumptions" class="anchor" href="#before-we-start-assumptions">¶</a>Before we Start: Assumptions</h2><div class="outline-text-2" id="text-org7269efd">
<p>
In order for the definitions and proofs in this post to make sense and be meaningful, we need to make a few assumptions.
</p>
</div>

<h3><a id="the-anatomy-of-a-lock-algorithm" class="anchor" href="#the-anatomy-of-a-lock-algorithm">¶</a>The Anatomy of a Lock Algorithm</h3><div class="outline-text-3" id="text-orgc12bcf3">
<p>
When analyzing a lock algorithm, we divide the code into a few parts:
</p>

<ul class="org-ul">
<li>Non-critical section:
This is the code part before the thread starts acquiring the lock. It does not have anything to do with the lock algorithm itself, but it is important to have it there: A thread is not simply acquiring and releasing a lock (with a critical section in between), but it also executes some non-critical code (that is, code that does not require mutual exclusion) before trying to acquire the lock. This is modelled with this non-critical section.</li>
<li><b>lock()</b> method:
We are going to refer to the algorithm that is executed to actually acquire the lock as <b>lock()</b> method. We split the <b>lock()</b> method into two parts, the doorway and the waiting section as listed below.</li>
<li>Doorway:
A <i>finite</i> part of the <b>lock()</b> method. Usually, flags are set and variables written that are used to coordinate and communicate with competing threads. Note that the doorway must contain a finite number of instructions, so it cannot contain for example spin-loops.</li>
<li>Waiting section:
A part of the <b>lock()</b> method that may contain an unbounded number of instructions. Usually, this section comes after the doorway and is simply a spin-wait to wait for some condition to be fulfilled (such that the thread can actually enter the critical section, i.e. acquire the lock).</li>
<li>Critical section:
This is the code that is executed while a thread actually holds the lock. Like with the non-critical section, the actual code here is irrelevant.</li>
<li><b>unlock()</b> method:
The code that is executed after the critical section to make the lock available again for other threads.</li>
</ul>

<p>
Let us see on the example of Peterson&rsquo;s algorithm how we would divide it up into these different sections:
</p>

<pre><span class="org-comment-delimiter">/* </span><span class="org-comment">non-critical section:</span>
<span class="org-comment"> * Code the thread executes before trying to acquire the lock</span>
<span class="org-comment-delimiter"> */</span>
flag[id] = <span class="org-constant">true</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">lock() method: doorway</span>
victim = id; <span class="org-comment-delimiter">// </span><span class="org-comment">lock() method: doorway</span>
<span class="org-keyword">while</span> (flag[1-id] == <span class="org-constant">true</span> &amp;&amp; victim == id); <span class="org-comment-delimiter">// </span><span class="org-comment">lock() method: waiting section</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">critical section</span>
flag[id] = <span class="org-constant">false</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">unlock() method</span></pre>
</div>

<h3><a id="the-progress-assumption" class="anchor" href="#the-progress-assumption">¶</a>The Progress Assumption</h3><div class="outline-text-3" id="text-org3c63964">
<p>
For many proofs, we make an assumption that is vital. Without it, many proofs do not make sense (because they would be wrong) and thus we need to clarify it. We call it the <i>progress assumption</i>.
We assume that threads in the <b>lock()</b> method, the critical section and the <b>unlock()</b> method have finite time in between instruction executions. That is, we assume every thread keeps executing its code (although note that it could be stuck in a loop). It must execute its next instruction in <i>some</i> finite time. Intuitively, this means that a thread cannot ``die&rsquo;&rsquo; in these parts of the code and we can assume it will eventually carry on with its algorithm, albeit after an arbitrarily long time. This assumption allows us to prove progress guarantees about algorithms using locks, even though this progress depends on other threads (if another thread holds the lock we depend on this thread releasing the lock at some point). However, we do not make this assumption for the non-critical section, which precedes the call to <b>lock()</b>. There, it is possible that a thread &ldquo;dies&rdquo; in the sense that it might enter an infinite loop for example.
</p>
</div>

<h2><a id="mutual-exclusion-and-deadlock-freedom" class="anchor" href="#mutual-exclusion-and-deadlock-freedom">¶</a>Mutual Exclusion and Deadlock-Freedom</h2><div class="outline-text-2" id="text-org40b8671">
<p>
Notice that all the discussed algorithms provide mutual exclusion (that is their primary point, so that is expected). A usable lock must at minimum provide deadlock-freedom in addition to mutual exclusion, so it is no surprise that they all provide that as well. Remember that deadlock-freedom here means that when at least one thread is contesting for the lock (called <b>lock()</b>, i.e. the thread is trying to acquire it), (at least) one of them is guaranteed to acquire it in finite time.
</p>
</div>

<h2><a id="fairness" class="anchor" href="#fairness">¶</a>Fairness</h2><h3><a id="fairness-in-a-lock" class="anchor" href="#fairness-in-a-lock">¶</a>Fairness in a Lock</h3><div class="outline-text-3" id="text-orgf1e8849">
<p>
First of all, there is no universal definition of fairness in the literature. Some sources consider fairness as something we refer to as starvation-freedom. We consider a lock algorithm to be fair, if it fulfills FIFO order. Note that FIFO (first-in-first-out) and first-come-first-served mean exactly the same thing.
</p>

<p>
The nice thing about this notion of fairness is the simple definition of a FIFO lock: A lock algorithm fulfills FIFO (or first-come-first-served) ordering, if and only if a thread that is &ldquo;first-in&rdquo; (compared to some other thread) is also guaranteed to acquire the lock first.
The hard part is then to define what &ldquo;first-in&rdquo; means. Let us first motivate why this is a very difficult definition: Assume we say &ldquo;first-in&rdquo; means that the thread first called <b>lock()</b>. However, this does not really give the &ldquo;first-in&rdquo; thread an advantage. It could be that the second thread starts executing the <b>lock()</b> method first, even though the other thread made the function call first. We see that this definition of &ldquo;first-in&rdquo; cannot be meaningful.
</p>

<p>
Another idea might be to define &ldquo;first-in&rdquo; such that some thread is &ldquo;first-in&rdquo; if it executed the first instruction of the <b>lock()</b> method before some other thread. However, what an instruction is, is quite arbitrary. Consider the Peterson lock. We can divide the first instruction into a load, modify and store and thus basically nullifying the advantage of the &ldquo;first-in&rdquo; thread. However, even when taking the actual Peterson algorithm, saying a thread is &ldquo;first-in&rdquo; if it raised its flag first, this would not guarantee that the thread acquires the lock first. So, with this &ldquo;first-in&rdquo; definition, Petersons algorithm would not be considered FIFO. However, Peterson&rsquo;s algorithm is quite universally considered FIFO. We need to find something else:
</p>

<p>
Remember our definition of the <b>lock()</b> method and its doorway and waiting section. We consider a thread P to be &ldquo;first-in&rdquo; compared to a competing thread Q, when P finishes its doorway section before Q starts its doorway section. And now, a lock algorithm fulfills FIFO ordering, if and only if one can divide its <b>lock()</b> method into a finite doorway and (possibly unbounded) waiting section, such that a thread being &ldquo;first-in&rdquo; compared to some other thread, is guaranteed to acquire the lock first.
</p>

<p>
This is not a terribly simple definition, but it is very precise.
</p>
</div>

<h3><a id="fairness-of-peterson" class="anchor" href="#fairness-of-peterson">¶</a>Fairness of Peterson</h3><div class="outline-text-3" id="text-orged4e8cc">
<p>
First, consider the following pseudo-code of the simple Peterson lock that provides mutual exclusion for two threads:
</p>
<pre><span class="org-comment-delimiter">// </span><span class="org-comment">shared fields</span>
<span class="org-type">bool</span> <span class="org-variable-name">flag</span>[2] = {<span class="org-constant">false</span>, <span class="org-constant">false</span>};
<span class="org-type">int</span> <span class="org-variable-name">victim</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">lock algo; id is either 0 or 1</span>
<span class="org-type">void</span> <span class="org-function-name">lock</span>(<span class="org-type">int</span> <span class="org-variable-name">id</span>) {
    <span class="org-type">int</span> <span class="org-variable-name">other</span> = 1 - id; <span class="org-comment-delimiter">// </span><span class="org-comment">other thread</span>
    flag[id] = <span class="org-constant">true</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">set own flag</span>
    victim = id; <span class="org-comment-delimiter">// </span><span class="org-comment">set itself as victim</span>
    <span class="org-keyword">while</span> (flag[other] &amp;&amp; victim == id) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">busy wait</span>
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">lock acquired, safely access shared resources now</span>
}

<span class="org-comment-delimiter">// </span><span class="org-comment">call after critical section ends</span>
<span class="org-type">void</span> <span class="org-function-name">unlock</span>(<span class="org-type">int</span> <span class="org-variable-name">id</span>) {
    flag[id] = <span class="org-constant">false</span>;
}</pre>

<p>
Petersons lock is easily shown to be fair when we consider the doorway and waiting section as described in the lock anatomy section: Assume thread P is first-in, which means according to above definition that it finished its doorway (i.e. set its flag and set the victim to its ID) before a competing thread Q started its doorway. Now either of the follwing happens:
</p>

<ul class="org-ul">
<li>The competing thread Q has still not started its doorway when P evaluates the condition of the waiting section for the first time. In that case, Q has not set its flag. Hence, P can advance to the critical section and will also do so before Q. This is because Q cannot advance unless either P sets the victim to its own id again or sets its flag to false. Both of which can only happen after P exited the critical section. So, Q is blocked and due to the progress assumption, P will enter the critical section in finite time, in particular before Q.</li>
<li>The competing thread Q has already entered the doorway section when P evaluates the condition of the waiting section for the first time. The progress assumption guarantees us that Q will finish the doorway in finite time and in particular will write victim=Q. Now, P can advance to the critical section and will do so before Q because of the same reasoning as in the first case (Q is blocked due to victim==Q and progress assumption guarantees P will continue eventually).</li>
</ul>

<p>
In all cases, P enters the critical section before Q, and thus the algorithm is fair.
</p>
</div>

<h3><a id="why-is-dekkerrsquos-algorithm-not-fair" class="anchor" href="#why-is-dekkerrsquos-algorithm-not-fair">¶</a>Why is Dekker&rsquo;s Algorithm not Fair?</h3><div class="outline-text-3" id="text-org2b64ba0">
<p>
Consider Dekkers Algorithm:
</p>

<pre><span class="org-comment-delimiter">// </span><span class="org-comment">shared fields</span>
<span class="org-type">boolean</span> <span class="org-variable-name">flag</span>[2] = { <span class="org-constant">false</span>, <span class="org-constant">false</span> };
<span class="org-type">int</span> <span class="org-variable-name">turn</span> = 1; <span class="org-comment-delimiter">// </span><span class="org-comment">can be either 0 or 1 (decides who goes first)</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">the locking algorithm</span>
<span class="org-type">void</span> <span class="org-function-name">lock</span>(<span class="org-type">int</span> <span class="org-variable-name">id</span>) {
    <span class="org-type">int</span> <span class="org-variable-name">other</span> = 1 - id;
    flag[id] = <span class="org-constant">true</span>;
    <span class="org-keyword">while</span> (flag[other]) {
        <span class="org-keyword">if</span> (turn == other) {
            flag[id] = <span class="org-constant">false</span>;
            <span class="org-keyword">while</span> (turn == other) {
                <span class="org-comment-delimiter">// </span><span class="org-comment">spin-wait</span>
            }
            flag[id] = <span class="org-constant">true</span>;
        }
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">lock acquired, safely access shared resources now</span>
}

<span class="org-type">void</span> <span class="org-function-name">unlock</span>() {
    turn = other;
    flag[id] = <span class="org-constant">false</span>;
}</pre>

<p>
Say now thread Q was &ldquo;first-in&rdquo; before thread P. Here, we can only define the doorway to be  instruction 2, the raising of the flag. This is because the doorway must contain a finite amount of instructions, and thus we cannot include any part of the while loop (lines 3-11). Thus, Q being &ldquo;first-in&rdquo; simply means it raised its flag first. Now, first-in does not guarantee us that Q evaluates the while-condition before P enters its doorway and raises its flag. If that happens, both Q and P have to execute their while-loops to decide who can enter first and there, the turn variable decides. If the turn is initialized to favor P, P will enter first here and thus, &ldquo;first-in-first-out&rdquo; is violated.
</p>
</div>

<h3><a id="why-is-the-filter-lock-not-fair" class="anchor" href="#why-is-the-filter-lock-not-fair">¶</a>Why is the Filter Lock not Fair?</h3><div class="outline-text-3" id="text-orgc348bd3">
<pre><span class="org-comment-delimiter">// </span><span class="org-comment">shared fields</span>
<span class="org-type">int</span> <span class="org-variable-name">level</span> [n] = { 0,0,...,0 };
<span class="org-type">int</span> <span class="org-variable-name">victim</span> [n];

<span class="org-comment-delimiter">// </span><span class="org-comment">lock algorithm</span>
<span class="org-type">void</span> <span class="org-function-name">lock</span>(<span class="org-type">int</span> <span class="org-variable-name">id</span>) {
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">l</span> = 1; l &lt; <span class="org-type">n</span>; l++) {
        level[id] = l;
        victim[l] = id;
        <span class="org-keyword">while</span> ((&#8707;k != id) (level[k] &gt;= l &amp;&amp; victim[l] == id)) {
            <span class="org-comment-delimiter">// </span><span class="org-comment">spin-wait</span>
        }
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">lock acquired, safely access shared resources now</span>
}

<span class="org-comment-delimiter">// </span><span class="org-comment">call after critical section ends</span>
<span class="org-type">void</span> <span class="org-function-name">unlock</span>(<span class="org-type">int</span> <span class="org-variable-name">id</span>) {
    level[id] = 0;
}</pre>
<p>
Consider a thread P that is &ldquo;first-in&rdquo; compared to some other thread Q at a level i in the filter lock. It is sufficient to show it is possible that Q can move on to level i+1 first to disprove fairness.
</p>

<p>
Then, being &ldquo;first-in&rdquo; means that P set its level to i and victim[i]=P (those two instructions can be defined as the doorway) before Q could do any of that. Now, consider an interleaving where Q sets its level to i and victim[i]=Q. Now, our thread P could advance, but assume it does not do so yet (remember, we only need to show it is <i>possible</i> that Q advances first, not that it <i>must</i> happen). Now, a third thread R enters level i and sets its level to i and victim[i]=R. Now, also Q can advance and nothing prevents Q from advancing before P does so. Hence, P can get overtaken and thus, fairness is violated.
</p>

<p>
Critical readers might now point out that our fairness definition only specified that <i>some</i> valid doorway definition must exist to show fairness. Hence, we would have to exhaustively show for all valid doorway/waiting partitions of the <b>lock()</b> method that FIFO can be violated. However, only showing this one provides enough intuition as to why the lock is not fair.
</p>
</div>

<h2><a id="starvation" class="anchor" href="#starvation">¶</a>Starvation</h2><h3><a id="proving-starvation-freedom-in-general" class="anchor" href="#proving-starvation-freedom-in-general">¶</a>Proving Starvation Freedom in General</h3><div class="outline-text-3" id="text-org5b8d551">
<p>
Starvation is a surprisingly simple property and formally means that any thread that calls <b>lock()</b> will acquire the lock in finite time (that is, the <b>lock()</b> method will terminate/return). So, to prove starvation freedom, we assume an arbitrary thread (that called <b>lock()</b>) and show that it will finish its <b>lock()</b> method in finite time.
</p>
</div>

<h3><a id="starvation-freedom-of-filter-lock" class="anchor" href="#starvation-freedom-of-filter-lock">¶</a>Starvation Freedom of Filter Lock</h3><div class="outline-text-3" id="text-org4b67b1e">
<pre><span class="org-comment-delimiter">// </span><span class="org-comment">shared fields</span>
<span class="org-type">int</span> <span class="org-variable-name">level</span> [n] = { 0,0,...,0 };
<span class="org-type">int</span> <span class="org-variable-name">victim</span> [n];

<span class="org-comment-delimiter">// </span><span class="org-comment">lock algorithm</span>
<span class="org-type">void</span> <span class="org-function-name">lock</span>(<span class="org-type">int</span> <span class="org-variable-name">id</span>) {
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">l</span> = 1; l &lt; <span class="org-type">n</span>; l++) {
        level[id] = l;
        victim[l] = id;
        <span class="org-keyword">while</span> ((&#8707;k != id) (level[k] &gt;= l &amp;&amp; victim[l] == id)) {
            <span class="org-comment-delimiter">// </span><span class="org-comment">spin-wait</span>
        }
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">lock acquired, safely access shared resources now</span>
}

<span class="org-comment-delimiter">// </span><span class="org-comment">call after critical section ends</span>
<span class="org-type">void</span> <span class="org-function-name">unlock</span>(<span class="org-type">int</span> <span class="org-variable-name">id</span>) {
    level[id] = 0;
}</pre>
<p>
Assume an arbitrary thread. It is sufficient to show that the thread can advance from some arbitrary level i to level i+1 in the filter lock in finite time. In a fully formal proof, the following reasoning would roughly correspond to the induction step (a formal proof would perform induction over the number of levels in the lock).
We proceed by case distinction:
</p>
<ul class="org-ul">
<li>Either, a new thread reaches level i and sets the victim to itself. Thus, our thread can advance (consider the while-condition of the filter lock) and will do so eventually due to the progress assumption.</li>
<li>Or, no other thread ever reaches level i after our thread. Say now that k threads are ahead (or on the same level) of our thread in the lock. Deadlock-freedom of the filter lock guarantees us that in finite time, one of them will acquire the lock and due to our progress assumption will finish the critical section and unlock in finite time as well. Now, k-1 threads remain ahead of our thread or on the same level. Remember that no additional threads can come, because we are in the case where no other thread ever reaches level i. We can simply use deadlock freedom (plus our progress assumption) again to reach a scenario with k-2 threads ahead of, or at the same level as our thread. We use deadlock freedom k times in total until no thread remains ahead of or on the same level as us.
Now, the while-loop evaluates to false and our thread can advance (and will do so eventually due to the progress assumption).</li>
</ul>

<p>
Since these two cases cover all possible scenarios, the statement follows (the thread can indeed reach level i+1 in finite time). Since the thread was arbitrary and we can extend this (imagine induction with this as the induction step) to all n levels in the lock, starvation freedom holds.
</p>

<p>
This case distinction should provide enough intuition as to why a thread must make progress (and thus cannot starve) in the filter lock: Again, either a new thread reaches the level and thus our thread can advance (because it is no longer the victim). Or, no thread comes, but then all the ones ahead must drain at some point and then the thread can advance also. If you simply remember this simple two-sentence reasoning, you will be able to reconstruct why the filter lock is starvation-free.
</p>
</div>

<h3><a id="why-are-locks-using-atomic-rmw-operations-not-starvation-free-and-not-fair" class="anchor" href="#why-are-locks-using-atomic-rmw-operations-not-starvation-free-and-not-fair">¶</a>Why are Locks using Atomic-RMW Operations not Starvation-Free (and not Fair)?</h3><div class="outline-text-3" id="text-org630e4bd">
<p>
Let us consider a spinlock using the atomic TAS (test-and-set) operation:
</p>

<pre><span class="org-type">void</span> <span class="org-function-name">lock</span>(<span class="org-type">boolean</span> <span class="org-variable-name">lk</span>) {
    <span class="org-keyword">while</span> (<span class="org-negation-char">!</span>testAndSet(lk)) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">spin-wait</span>
    }
}

<span class="org-type">void</span> <span class="org-function-name">unlock</span>(<span class="org-type">boolean</span> <span class="org-variable-name">lk</span>) {
    lk = <span class="org-constant">false</span>;
}</pre>

<p>
This is pseudo-code. Remember the semantics of test-and-set: The operation <i>atomically</i> checks whether <b>lk</b> is false and writes it to true if it is. In that case, the operation succeeded, and test-and-set returns true. If <b>lk</b> is already set to true, the operation fails and test-and-set returns false.
</p>

<p>
Now, a thread tries to acquire the lock by calling <b>lock()</b> and spins in the while loop until test-and-set returns true. It could return false because another thread currently holds the lock. Our progress assumption guarantees us however that this thread will finish its critical section and release the lock in a finite amount of time. But even then, test-and-set can fail again when a competing thread succeeds and our thread fails. There is nothing about these atomic read-modify-write operations that guarantees us something about the ordering that competing threads succeed. Our thread could simply never succeed, because every time the lock is released again, another thread that also executes the TAS operation could succeed and thus our thread fails.
</p>

<p>
With the same reasoning, one can also show trivially that these locks are not fair. The <b>lock()</b> method consists <i>only</i> of a waiting section, there is no possibility of defining a doorway (because a doorway must contain a bounded number of instructions, so no spin-loops allowed). Hence, being &ldquo;first-in&rdquo; means essentially nothing for such locks, since it does not even guarantee that the &ldquo;first-in&rdquo; thread starts executing the atomic operation first.
</p>
</div>

<h3><a id="how-can-it-be-that-atomic-rmw-based-locks-are-used-then" class="anchor" href="#how-can-it-be-that-atomic-rmw-based-locks-are-used-then">¶</a>How can it be that Atomic-RMW based Locks are Used then?</h3><div class="outline-text-3" id="text-org3f24361">
<p>
This is not super relevant knowledge for the exam, but it may answer some questions and concerns interested readers may have and provide some food for thought.
It may seem strange, as we defined a correct lock needs to fulfill starvation freedom. However, locks based on atomic-RMW operations are the only lock implementation actually used in modern systems and they are <i>not</i> starvation-free. How can this be? Starvation-freedom is just not a super important property. Think about it, a lock that can deadlock is unusable. Even when the probability of it deadlocking is low, such an algorithm deployed in, say, a banking system could prove fatal. This is because there is by definition no escape from a deadlock. The system is just in a state where it cannot get out of. But what the lack of starvation-freedom in atomic spinlocks means, is that <i>technically</i>, the atomic operation could always fail (due to contention). In the sense that there is nothing that guarantees us that it will eventually succeed. But, the probability of this happening is 0. Because to actually starve, a thread would need to try the atomic operations an infinite amount of times and fail every single time.
</p>

<p>
In an actual implementation, using backoff, the probability of failing multiple times in a row is already extremely low. But, it <i>could</i> technically happen that the atomic operation just keeps failing. That is why we are not guaranteed starvation freedom. But, this barely has any implications on a real-world implementation.
</p>

<p>
To further emphasize how starvation-freedom and deadlock-freedom relate, consider a deadlock-free lock algorithm. Let us assume we have a finite number <i>n</i> of threads that try to acquire the lock. Each of those n threads can also acquire the lock at most k times in total (cannot reenter <b>lock()</b> more than k times). These are strong assumptions, but in a real-world scenario, threads are probably not going to access a lock an infinite amount of times anyways and we also do not have an infinite number of threads. So, they are strong assumptions, but not entirely unrealistic. The key point is, we have at most n*k lock acquisitions in total, which is a finite number.
</p>

<p>
Now, deadlock-freedom guarantees us that at least one of the competing threads will succeed in acquiring the lock. Due to our progress assumption, we also have that this successful thread completes the critical section and releases the lock again in finite time. Thus, we land in a scenario where there are at most n*k-1 competing lock acquisitions in a finite time. We can again apply deadlock-freedom here to get to a scenario with at most n*k-2 competing acquisitions and so on. At the end, all of the n*k competing acquisition attempts must succeed (by applying deadlock-freedom n*k-1 times). Thus, we have starvation-freedom. We see that in such a scenario (where the total number of acquisition attempts is bounded), starvation-freedom and deadlock-freedom are equivalent. Starvation-freedom can only be a stronger criterion than deadlock-freedom when we have an infinite number of lock acquisitions.
</p>
</div>
</div></div></div></body></html>
